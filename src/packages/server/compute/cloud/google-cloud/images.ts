/*
Working with Google Cloud images.

The Google cloud api from https://www.npmjs.com/package/@google-cloud/compute for images
is in theory documented at:

- https://cloud.google.com/compute/docs/reference/rest/v1/images
- https://github.com/googleapis/google-cloud-node/blob/main/packages/google-cloud-compute/src/v1/images_client.ts

The only way to actually use it is really study the docs *and* the
autogenerated typescript definitions.

Do not bother with any LLM's, at least as of Sept 2023, as they all (Bard, GPT-4, etc.)
are incredibly wildly wrong about everything about @google-cloud/compute.  Hopefully
this will change someday, since it would be nice, and all the information to correctly
train those models is available on github.  But oh my god what a nightmare.

In any case, typescript for the win here.
*/

import { createDatabaseCachedResource } from "@cocalc/server/compute/database-cache";
import { getCredentials } from "./client";
import { ImagesClient } from "@google-cloud/compute";
import type {
  Architecture,
  GoogleCloudConfiguration,
  GoogleCloudImage,
  GoogleCloudImages,
} from "@cocalc/util/db-schema/compute-servers";
import { getArchitecture as getArchitecture0 } from "@cocalc/util/db-schema/compute-servers";
import { makeValidGoogleName } from "@cocalc/util/db-schema/compute-servers";
import { cmp } from "@cocalc/util/misc";
import { getGoogleCloudImagePrefix } from "./index";
import { imageDeprecation } from "@cocalc/server/compute/cloud/startup-script";
import { COMPUTE_SERVER_IMAGES } from "@cocalc/server/compute/images";
import { delay } from "awaiting";
import getLogger from "@cocalc/backend/logger";

const logger = getLogger("server:compute:google-cloud:images");

// Return the latest available image of the given type on the configured cluster.
// Returns null if no images of the given type are available.

export async function imageName({
  image,
  tag,
  arch,
}: {
  image: string;
  tag: string;
  arch: Architecture;
}) {
  return `${await getGoogleCloudImagePrefix()}-${makeValidGoogleName(
    image,
  )}-${makeValidGoogleName(tag)}${arch == "x86_64" ? "" : `-${arch}`}`; // _ not allowed
}

let client: ImagesClient | undefined = undefined;
let projectId: string | undefined;
export async function getImagesClient() {
  if (client != null && projectId != null) {
    return { client, projectId };
  }
  const credentials = await getCredentials();
  client = new ImagesClient(credentials);
  projectId = credentials.projectId as string;
  return { client, projectId };
}

// filters are documented at https://cloud.google.com/sdk/gcloud/reference/topic/filters/
// and "The matching is anchored and case insensitive. An optional trailing * does a
// word prefix match."

// 1 hour default ttl -- data stored in the database,
// and some operations like building new images
// update this.
const TTL_MS = 1000 * 60 * 60;
const GOOGLE_CLOUD_IMAGES_SERVER_SETTINGS = `${COMPUTE_SERVER_IMAGES}-google-cloud`;

export const { get: getAllImages } = createDatabaseCachedResource<{
  [name: string]: GoogleCloudImage;
}>({
  ttl: TTL_MS,
  cloud: "google",
  key: GOOGLE_CLOUD_IMAGES_SERVER_SETTINGS,
  fetchData: fetchImagesFromGoogleCloud,
});

export async function fetchImagesFromGoogleCloud({
  labels,
}: {
  labels?: object;
} = {}): Promise<GoogleCloudImages> {
  logger.debug("fetchImagesFromGoogleCloud", labels);
  const prefix = `${await getGoogleCloudImagePrefix()}-`;
  const { client, projectId } = await getImagesClient();
  let filter = `name:${prefix}*`;
  if (labels != null) {
    for (const key in labels) {
      filter += ` AND labels.${key}=${labels[key]} `;
    }
  }
  const [images] = await client.list({
    project: projectId,
    maxResults: 2000, // should never be close to this.
    filter,
  });

  // there's a lot of extra info in images that we don't need to store.
  const data: GoogleCloudImages = {};
  for (const { name, labels, diskSizeGb, creationTimestamp } of images) {
    if (!name) continue;
    data[name] = {
      labels,
      diskSizeGb: parseInt(diskSizeGb as string),
      creationTimestamp,
    } as unknown as GoogleCloudImage;
  }
  return data;
}

// Returns true if the image currently exists; false, otherwise.
export async function imageExists(name: string): Promise<boolean> {
  const { client, projectId } = await getImagesClient();
  const filter = `name:${name}`;
  const [images] = await client.list({
    project: projectId,
    maxResults: 1,
    filter,
  });
  logger.debug("imageExists:", name, images.length > 0);
  return images.length > 0;
}

export async function deleteImage(name: string) {
  logger.debug("deleteImage:", name);
  const { client, projectId } = await getImagesClient();
  await client.delete({
    project: projectId,
    image: name,
  });
  const t0 = Date.now();
  let n = 5000;
  // this can take a while -- we give it 15 minutes.
  while (Date.now() - t0 <= 1000 * 60 * 15) {
    if (!(await imageExists(name))) {
      logger.debug("deleteImage: ", name, "confirmed deleted");
      return;
    }
    n = Math.min(15000, n * 1.3);
    logger.debug(
      `deleteImage: ${name} waiting `,
      n / 1000,
      "seconds for image to be deleted...",
    );
    await delay(n);
  }
  throw Error(`image creation did not finish -- ${name}`);
}

export function getArchitecture(machineType: string): Architecture {
  return getArchitecture0({ machineType, cloud: "google-cloud" } as any);
}

export async function getSourceImage({
  image,
  tag,
  machineType,
}: GoogleCloudConfiguration): Promise<{
  sourceImage: string;
  diskSizeGb: number;
}> {
  logger.debug("getSourceImage", {
    image,
    tag,
    machineType,
  });
  image = imageDeprecation(image);
  const arch = getArchitecture(machineType);
  const googleImages = await getAllImages();
  const { projectId } = await getCredentials();

  if (tag) {
    const name = await imageName({ image, tag, arch });
    const x = googleImages[name];
    if (x != null) {
      return {
        sourceImage: `projects/${projectId}/global/images/${name}`,
        diskSizeGb: x.diskSizeGb,
      };
    }
    // failed to find image with the exactly specified tag.
    throw Error(
      `Image '${name}' is not currently available on Google cloud -- please change the image, possibly in advanced settings`,
    );
  }
  // choose source based on what is available -- best tested image if there is one;
  // otherwise, an untested image.  This is mainly for old compute servers, since newer
  // ones are likely to have the tag set.
  const options: (GoogleCloudImage & { name: string })[] = [];
  for (const name in googleImages) {
    const x = googleImages[name];
    if (
      makeValidGoogleName(image) == x.labels?.image &&
      makeValidGoogleName(arch) == x.labels?.arch
    ) {
      options.push({ name, ...x });
    }
  }
  // best at beginning
  options.sort((a, b) => {
    const a_tested = a.labels?.["tested"];
    const b_tested = b.labels?.["tested"];
    if (a_tested && !b_tested) {
      // a is better
      return -1;
    }
    if (b_tested && !a_tested) {
      // b is better
      return 1;
    }
    // compare based on timestamp
    return -cmp(a.creationTimestamp, b.creationTimestamp);
  });
  if (options.length > 0) {
    const x = options[0];
    return {
      sourceImage: `projects/${projectId}/global/images/${x.name}`,
      diskSizeGb: x.diskSizeGb,
    };
  }
  throw Error(
    `No prebuilt image for '${image}' on Google Cloud -- please change the image`,
  );
}

// name = exact full name of the image
// labels: object key:value map.  Use value=null/undefined to delete keys.
//        keys not mentioned in label are ignored.
export async function setImageLabels({
  name,
  labels: changes,
}: {
  name: string;
  labels: { [key: string]: string | null | undefined };
}) {
  logger.debug("setImageLabels", { name, changes });
  const { client, projectId } = await getImagesClient();
  const i = name.lastIndexOf("/");
  if (i != -1) {
    name = name.slice(i + 1);
  }
  const [image] = await client.get({
    project: projectId,
    image: name,
  });
  let labels, labelFingerprint;
  ({ labels, labelFingerprint } = image);
  if (labels == null) {
    labels = {};
  }
  for (const key in changes) {
    const value = changes[key];
    if (value == null) {
      if (labels[key] == null) {
        // nothing to do
        continue;
      }
      delete labels[key];
    } else {
      labels[key] = `${value}`;
    }
  }

  await client.setLabels({
    project: projectId,
    resource: name,
    globalSetLabelsRequestResource: {
      labels,
      labelFingerprint,
    },
  });
}
export async function setTested(
  { image, tag, machineType }: GoogleCloudConfiguration,
  tested: boolean,
) {
  logger.debug("setTested", {
    image,
    tag,
    machineType,
    tested,
  });
  image = imageDeprecation(image);
  const arch = getArchitecture(machineType);
  if (!tag) {
    throw Error("tag must be set");
  }
  const name = await imageName({ image, tag, arch });
  await setImageLabels({ name, labels: { tested: tested ? "true" : null } });
}
